---

name: Реализация интерфейсов классами
theory: |

  В TypeScript классы могут тесно взаимодействовать с интерфейсами. В прошлом уроке мы увидели как интерфейсы могут расширять другие интерфейсы и комбинировать их. Аналогичным образом интерфейсы могут быть расширены классами:

  ```typescript
  interface IBeep {
    sayBeep: () => string;
  }

  interface IBoop {
    sayBoop: () => string;
  }

  class Robo implements IBeep, IBoop {
    sayBeep = () => 'beep';
    sayBoop = () => 'boop';
  }

  const R2D2 = new Robo();
  R2D2.sayBeep(); // 'beep'

  // Здесь мы расширили два интерфейса с помощью класса, который унаследовал все методы данных интерфейсов.  Обратите внимание, нам пришлось вручную прописать унаследованные методы.
  ```

  Мы можем создавать классы на основе интерфейсов так же, как мы создаем интерфейсы на основе интерфейсов. Но есть и отличия.

  Если мы создаем интерфейс или тип и потом транспилируем TypeScript в JavaScript, то в коде не останется образца этого интерфейса. В то же время при создании класса его образец всегда переносится и в JavaScript при транспиляции.

  Так можно сказать, что вариант с интерфейсами более легковесный, но все же выбор должен зависеть от задачи, которую мы решаем.

  Создание класса на основе интерфейса не ведет к точной реализации этого интерфейса в классе. TypeScript просто проверяет, удовлетворяют ли свойства и методы нашего класса свойствам, заявленным в интерфейсе. Сам же класс мы пишем вручную. Рассмотрим пример:

  ```typescript
  interface ICalculate {
    sum: (num1: number, num2: number ) => number;
  }

  class Summator implements ICalculate {
    sum(num1, num2) { return num1 + num2; }
    // Для параметров будет выведено сообщение: Parameter 'num1'/'num2' implicitly has an 'any' type,
    // потому что TypeScript только проверяет класс на соответствие интерфейсу, но не наследуется от него полноценно

    multiply(num1: number, num2: number) { return num1 * num2; }
    // Мы добавили новый метод, но TypeScript не ругается
  }

  let calculator = new Summator();
    // Наш код сработает, как если бы он сработал для аргументов с типом any,
    // потому что типы параметров, равно как и все остальное, не были унаследованы классом при реализации интерфейса
  calculator.sum(2,3) // 5
  ```

  Ошибка в реализации интерфейса классом возможна только тогда, когда мы не реализуем одно из свойств, указанных в интерфейсе. Или мы реализуем его не так, как указано в интерфейсе:

  ```typescript
  interface ICalculate {
    sum: (num1: number, num2: number ) => number;
  }

  class Summator implements ICalculate {
    sum (num1: string, num2: string) { return num1 + num2 };
    // Мы изменили типы аргументов на string, то есть неверно реализовали интерфейс
    // В таком случае TypeScript обратит внимание на нашу ошибку и не скопилируется:
    // Type '(num1: string, num2: string) => string' is not assignable to type '(num1: number, num2: number) => number'.
  }
  ```

  По этой же причине, если мы пишем класс, реализующий интерфейс с опциональными свойствами, нам нужно прописывать все самостоятельно. В противном случае эти свойства не попадут в наш класс:

  ```typescript
  interface ICalculate {
    sum: (num1: number, num2: number ) => number;
    multiply? : (num1: number, num2: number ) => number;
  }

  class Summator implements ICalculate {
    sum (num1: number, num2: number) { return num1 + num2; }
  }

  const calculator = new Summator();
  calculator.sum(2,3) // 5
  calculator.multiply(2,3) // Property 'multiply' does not exist on type 'Summator'.
  ```

  В примере выше мы не реализовали метод multiply при реализации интерфейса классом Summator. В результате компилятор не выдал нам ошибку, ведь этот метод был указан как опциональный. В то же время, в экземпляре нашего класса мы не можем обратиться к этому методу.

  Поскольку в TypeScript для одних и тех же вещей существует несколько разных инструментов, мы можем реализовывать классы с помощью расширения абстрактных классов вместо интерфейсов. Но выбор будет зависеть от задачи. Абстрактные классы предоставляют нам модификаторы доступа и конструкторы, в то время как интерфейсы более легковесны и просты.

instructions: |

  С помощью предоставленного интерфейса IPhonebook и типа Entry реализуйте и экспортируйте по умолчанию класс Phonebook, который представляет телефонный справочник со следующими свойствами:

  - `entries` — база данных, объект, записи в котором представляют собой имена в качестве ключей и телефоны в качестве значений. Свойство должно быть неизменяемым и доступным только для чтения
  - `get` — метод, возвращающий телефон по имени
  - `set` — метод, записывающий имя и телефон в справочник

  Примеры:
  ```typescript
  const myNote = new Phonebook();
  myNote.set('help', 911);
  myNote.get('help'); // 911
  ```
