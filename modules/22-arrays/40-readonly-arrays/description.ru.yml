---

name: Массивы только для чтения
theory: |

  В разработке на JavaScript, где активно применяются функции высшего порядка, такие как `map`, `filter` и `reduce`, массивы меняются редко. Обычно вместо этого создаются новые.

  Технически JavaScript не может запретить изменять существующие массивы, поэтому ответственность за соблюдение этого правила лежит на программистах. В этом уроке разберем работу с массивами только для чтения.

  В TypeScript работа с неизменяемыми массивами встроена в систему типов. Чтобы гарантировать неизменяемость, массив помечается модификатором `readonly`:

  ```typescript
  function process(numbers: readonly number[]) {
    numbers.push(1); // Error!
  }
  ```

  В этом случае TypeScript выдает ошибку, что тип `readonly number[]` не содержит метода `push`.

  Модификатор `readonly` запрещает изменение массива, но не запрещает изменение объектов, которые находятся внутри массива:

  ```typescript
  const items: readonly ({ key: string })[] = [{ key: 'value'}];
  items[0].key = 'another value'; // ok!
  ```

  Мы успешно изменили значение свойства `key` в объекте, который находится внутри массива.

  Модификатор `readonly` — синтаксический сахар. В случае массива `readonly` меняет тип `Array` на тип `ReadonlyArray`. Такая запись, как и `Array<Type>` улучшает читабельность кода, но в остальном ничем не отличается от `readonly Type[]`. Код выше можно было бы записать так:

  ```typescript
  const items: ReadonlyArray<{ key: string }> = [{ key: 'value'}];
  ```

instructions: |

  Реализуйте функцию `reverse()`, которая переворачивает массив. Технически она должна возвращать новый массив, в котором элементы расположены в обратном порядке. Используйте модификатор `readonly` для входящего массива. Не используйте встроенный метод `reverse()`.

  ```typescript
  reverse([1, 2, 8]); // [8, 2, 1]
  reverse([10, 33, 7, 0]); // [0, 7, 33, 10]
  ```

tips:
  - |
    [Массивы только для чтения и кортежи](https://mariusschulz.com/blog/read-only-array-and-tuple-types-in-typescript/)
