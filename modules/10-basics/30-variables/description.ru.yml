---

name: Переменные
theory: |

  Переменные и константы в TypeScript определяются точно так же как и в JavaScript:

  ```typescript
  let age = 10;

  let company = 'Hexlet';
  let user = {
    firstName: 'Miro',
  };
  let fruits = ['apple', 'banana'];
  ```

  Несмотря на внешню идентичность, TypeScript выполняет дополнительную работу на фоне. Он автоматически связывает переменную (или константу) с типом данных значения начального значения. В программировании такой процесс называется выводом типов.

  Тип переменной поменяться не может:

  ```typescript
  let age = 10;
  // Все нормально, тип тот же (Number)
  age = 11.1;

  // Type 'string' is not assignable to type 'number'.
  age = 'boom!';
  ```

  Если мы попытаемся передать эту переменную в метод, который ожидает другой тип, то это тоже приведет к ошибке:

  ```typescript
  // Argument of type 'number' is not assignable to parameter
  // of type '(substring: string, ...args: any[])
  'hexlet'.replace('xl', age);
  ```

  Статическая типизация накладывает ограничение на массивы, внутри могут храниться данные только одного типа:

  ```typescript
  let items = [1, 2, 3];
  items.push(4); // Все хорошо

  // Argument of type 'string' is not assignable to parameter of type 'number'.
  items.push('boom!');
  ```

  С объектами ситуация еще строже. В TypeScript нельзя не только менять тип свойств внутри объекта, но и добавлять новые свойства динамически.


  ```typescript
  let user = {
    firstName: 'Miro',
  };

  // Property 'lastName' does not exist on type '{ firstName: string; }'.
  user.lastName = 'Smith';
  ```

  ## Явное указание типа

  Технически, TypeScript позволяет явно указывать тип переменных. На практике это редко нужно, так как работает выводов типов.

  ```typescript
  let name: string = 'Alice';
  const count: number = 100;
  let canPlay: boolean = true;
  ```

  ## Null

  По умолчанию в TypeScript переменные могут содержать только указанный тип без исключений, например мы не можем присвоить null:

  ```typescript
  let age = 30;
  age = null;
  ```

  Такое поведение защищает нас от большого числа ошибок, связанных с отсутствием проверок на null. С другой стороны, иногда `null` является допустимым значением. В этом случае используется специальный Union Type:

  ```typescript
  let age: string | null = 30;
  age = null;
  ```

  Здесь мы указали, что тип у переменной `age` это `string | null`. Читается это как: "строка или null". Union Type интересная и удобная концепция, которую мы рассмотрим подробнее позже.

instructions: |

  Допишите тело функции `repeat()`, которая повторяет строку указанное количество раз без использования встроенных методов. Для такой реализации вам понадобится цикл.

  ```typescript
  repeat('hexlet', 2); // hexlethexlet
  repeat('wo', 3); // wowowo
  ```

# tips:
#   - |
#     [Ruby-комьюнити](https://slack-ru.hexlet.io/)
