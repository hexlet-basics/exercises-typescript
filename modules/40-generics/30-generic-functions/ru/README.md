
Представим, что дженерики пропали из языка. Тогда произойдет дублирование кода. Придется описывать один и тот же алгоритм для разных типов данных много раз.

Возьмем для примера функцию `last()`, возвращающую последний элемент массива. Ниже ее обобщенная версия:

```typescript
function last<T>(coll: T[]): T {
  return coll[coll.length - 1];
}
```

Дженерики также могут использоваться в стрелочных функциях:

```typescript
const last = <T>(coll: T[]): T => {
  return coll[coll.length - 1];
};
```

<!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

Теперь попробуем реализовать то же поведение, но без применения дженериков. Для этого нам придется создать по одной функции для каждого типа. Причем имя функции должно быть уникальным:

```typescript
function lastForNumberType(coll: number[]): number {
  return coll[coll.length - 1];
}

function lastForStringType(coll: string[]): string {
  return coll[coll.length - 1];
}

// Тут определения для всех остальных типов
```

<!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

Если типов несколько, то количество функций, которые нужно определить, будет определяться как произведение количества всех возможных типов на количество параметров типа.

Реализация дженерика с помощью перегруженной функции упрощает задачу. Тогда не придется создавать новые имена:

```typescript
function last(coll: number[]): number;
function last(coll: string[]): string;
// Тут определения для всех остальных типов

function last(coll: any[]): any {
  return coll[coll.length - 1];
}
```

<!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

В случае TypeScript даже не будет дублироваться логика, но это особенность именно TypeScript. В других статически типизированных языках придется дублировать и логику.

Какой бы вариант реализации мы не выбрали, соблюдаются две вещи:

* Значения, передаваемые во внутрь, никак не используются. Они только перекладываются из одного места в другое
* Логика работы всегда остается одной и той же. Условные конструкции по типу данных отсутствуют

В Computer Science свойство функции, позволяющее обрабатывать значения разных типов одним способом (используя один алгоритм), называется параметрическим полиморфизмом. То есть дженерики — это реализация параметрического полиморфизма в TypeScript.

Параметрический полиморфизм играет важную роль в статически типизированных языках там, где приходится явно указывать типы у функций. Он есть почти во всех высокоуровневых статически типизированных языках. В Java и C# это тоже называется дженериками. В C++ используется названия шаблоны, но смысл от этого не меняется, хотя шаблоны в С++ — это больше, чем параметрический полиморфизм.

В противовес статически типизированным языкам в языках с динамической типизацией, таких как JavaScript, Python, Ruby, PHP, дженерики не нужны. В подобных языках любой обобщенный алгоритм автоматически работает для всех типов данных.
