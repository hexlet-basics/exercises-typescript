
Использование типа `any` в TypeScript отключает проверки типов, что не желательно. Также в наиболее строгом режиме с помощью `"strict": true` в `tsconfig.json` использование `any` невозможно. А это значительно повышает безопасность кода.

При этом бывают ситуации, когда тип неизвестен, но работа с ним должна быть безопасна с точки зрения типов. Для этого в TypeScript существует дополнение к `any` — `unknown`, которое разберем в этом уроке.

## Использование типа unknown

Главное отличие `unknown` от `any` связано с проверкой типов. `unknown` запрещает выполнять любые операции:

```typescript
let value: unknown = 'code-basics';

value.toUpperCase(); // Error!
value.trim(); // Error!
```

Может показаться странным, что перед нами строка, но над ней нельзя выполнять строковые операции. К этому надо привыкнуть. Тип в статически типизированных языках определяется не тем, что мы видим своими глазами, а тем, как тип выводится — автоматически или через явное указание.

Переменная `unknown` типа нужна редко — когда нужно дальше уточнить тип. Но все меняется, когда нам нужно создать функцию, которая может работать с любым входящим типом. В JavaScript распространена подобная практика:

```typescript
// Пример из lodash
_.isError(new Error); // true
_.isError(Error); // false
_.isError('code-basics'); // false
```

Такую функцию можно реализовать с помощью `any`, но тогда мы отключим проверку типов:

```typescript
function isError(value: any)
```

Лучше использовать `unknown`, тогда TypeScript защитит от потенциальных ошибок типов:

```typescript
function isError(value: unknown)
```

Затем внутри тела можно выполнить нужную проверку, чтобы узнать, с чем мы работаем:

```typescript
function isError(value: unknown): boolean {
  return value instanceof Error;
}
```

`instanceof` работает только с конструкторами, поэтому в примере выше мы проверяем, является ли значение экземпляром класса `Error`.
