---

name: Тип unknown
theory: |

  Использование типа `any` в TypeScript отключает проверки типов, что не желательно. Также в наиболее строгом режиме с помощью `"strict": true` в `tsconfig.json` использование `any` невозможно. А это значительно повышает безопасность кода.
  
  При этом бывают ситуации, когда тип неизвестен, но работа с ним должна быть безопасна с точки зрения типов. Для этого в TypeScript существует дополнение к `any` — `unknown`, которое разберем в этом уроке.

  Главное отличие `unknown` от `any` связано с проверкой типов. `unknown` запрещает выполнять любые операции:

  ```typescript
  let value: unknown = 'code-basics';

  value.toUpperCase(); // Error!
  value.trim(); // Error!
  ```

  Может показаться странным, что перед нами строка, но над ней нельзя выполнять строковые операции. К этому надо привыкнуть. Тип в статически типизированных языках определяется не тем, что мы видим своими глазами, а тем, как тип выводится — автоматически или через явное указание.

  Вы вряд ли захотите явно иметь переменную `unknown` типа. Но все меняется, когда нам нужно создать функцию, которая может работать с любым входящим типом. В JavaScript распространена подобная практика:

  <!--TODO - автору: почему студент не захочет явно иметь переменную? нужно пояснить этот момент. -->

  ```typescript
  // Пример из lodash
  _.isError(new Error); // true
  _.isError(Error); // false
  _.isError('code-basics'); // false
  ```

  Такую функцию можно реализовать с помощью `any`, но тогда мы отключим проверку типов:

  ```typescript
  function isError(value: any)
  ```

  Лучше использовать `unknown`, тогда TypeScript защитит от потенциальных ошибок типов:

  ```typescript
  function isError(value: unknown)
  ```

  Затем внутри тела можно выполнить нужную проверку, чтобы узнать, с чем мы работаем:

  ```typescript
  function isError(value: unknown): boolean {
    return value instanceof Error;
  }
  ```

  `instanceof` работает только с конструкторами, поэтому в примере выше мы проверяем, является ли значение экземпляром класса `Error`.

instructions: |

  Реализуйте функцию `isPlainObject()`, которая проверяет, является ли переданное значение объектом. Эта функция считает, что массив не объект:

  ```typescript
  isPlainObject(1); // false
  isPlainObject('hexlet'); // false
  isPlainObject({}); // true
  isPlainObject({ name: 'code-basics' }); // true
  isPlainObject([1, 8]); // false
  ```
