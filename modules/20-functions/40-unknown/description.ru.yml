---

name: Тип unknown
theory: |

  Использование типа `any` в TypeScript нежелательно. В наиболее строгом режиме (оно настраивается) использование `any` невозможно, что значительно повышает типобезопасность кода. Но бывают ситуации, когда тип неизвестен, но работа с ним должна быть типобезопасна. Для этого в TypeScript существует дополнение к `any` — `unknown`, которое разберем в этом уроке.
  
  <!--TODO - автору: первый абзаца выше непонятен. 1. Почему использование типа `any` в TypeScript нежелательно? Нужно объяснить. 2. Что за наиболее строгий режим? 3. "Оно настраивается" - что оно? 4. Студент будет понимать, что такое типобезопасность?-->

  Главное отличие `unknown` от `any` связано с проверкой типов. `unknown` запрещает выполнять любые операции:

  ```typescript
  let value: unknown = 'code-basics';

  value.toUpperCase(); // Error!
  value.trim(); // Error!
  ```

  Может показаться странным, что перед нами строка, но над ней нельзя выполнять строковые операции. К этому надо привыкнуть. Тип в статически типизированных языках определяется не тем, что мы видим своими глазами, а тем, как тип выводится — автоматически или через явное указание.

  Пример выше на практике смысла не имеет. Но все меняется, когда нам нужно создать функцию, которая может работать с любым входящим типом. В JavaScript подобная практика достаточно распространена:
  
  <!--TODO - автору: что значит — "Пример выше на практике смысла не имеет". Почему не имеет?-->

  ```typescript
  // Пример из lodash
  _.isError(new Error); // true
  _.isError(Error); // false
  _.isError('code-basics'); // false
  ```

  Такую функцию можно реализовать с помощью `any`, но тогда придется быть очень аккуратным внутри и надеяться только на себя:
  
  <!--TODO - автору: почему нужно быть аккуратным? что может произойти? нужно объяснить. -->

  ```typescript
  function isError(value: any)
  ```

  Лучше использовать `unknown`, тогда TypeScript защитит от потенциальных ошибок типов:

  ```typescript
  function isError(value: unknown)
  ```

  Затем внутри тела можно выполнить нужную проверку, чтобы узнать, с чем мы работаем:

  ```typescript
  function isError(value: unknown): boolean {
    return value instanceof Error;
  }
  ```
  
  <!--TODO - автору: не хватает описания - на что здесь нужно обратить внимание?-->
  
instructions: |

  Реализуйте функцию `isPlainObject()`, которая проверяет, является ли переданное значение объектом. Эта функция считает, что массив не объект:

  ```typescript
  isPlainObject(1); // false
  isPlainObject('hexlet'); // false
  isPlainObject({}); // true
  isPlainObject({ name: 'code-basics' }); // true
  isPlainObject([1, 8]); // false
  ```

# tips:
