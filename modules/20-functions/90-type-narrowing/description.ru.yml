---

name: Narrowing
theory: |

  В JavaScript часто встречается код, в котором в одних и тех же переменных могут быть значения разных типов. Они обрабатываются на основе логических проверок с помощью `typeof` и других подобных механизмов.
  
  Ниже пример реализации функции, который конвертирует любое переданное значение в булево с учетом веб-специфики, где пустые строки, объекты и массивы считаются `false`:
  
  <!--TODO - автору: сложно предложение. 1. Не понятно, кто конвертирует переданное значение 2. Студент будет понимать значения слов булево, веб-специфика? Если нет, нужно сделать понятнее-->

  ```typescript
  function isPresence(value: unknown): boolean {
    if (value === null || value === undefined) {
      return false;
    }
    // пустая строка
    if (typeof value === 'string') {
      if (value === '') {
        return false;
      }
    }
    // пустой массив
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return false;
      }
    }
    // пустой объект
    if (value instanceof Object) {
      if (Object.keys(value).length === 0) {
        return false;
      }
    }

    return true;
  }

  isPresence(''); // false
  isPresence({}); // false
  isPresence([]); // false
  isPresence([1, 3]); // true
  isPresence(10); // true
  ```

  В этом коде параметр имеет тип `unknown`. Внутри TypeScript позволяет выполнять с этим параметром разные действия. Они будут зависеть от заданных условий.
  
  В этом случае проверка типов выполняется статически до запуска кода. А условия внутри функции — это часть кода, который выполняется в рантайме, то есть во время запуска программы. Получается, что такой код должен был бы завершиться с ошибкой, но этого не происходит.

  Так как подобный код в JavaScript встречается часто, то систему типов TypeScript пришлось доработать так, чтобы осталась возможность писать подобный код.
  
  В данном случае оказывается, что TypeScript умеет выполнять часть условных конструкций статически, как проверку совместимости типов, без запуска кода. Затем внутри блока с условием компилятор считает, что тип значения совпадает с тем, что было в самой проверке. Этот процесс в TypeScript называется **Type Narrowing** — сужение типа.

  Narrowing работает не только для типа `unknown`. Это универсальный механизм, который работает со всеми возможными типами, например, Union Types:

  ```typescript
  function foo(value: number | string) {
    if (typeof value === 'number') {
      // Работаем как с числом
    }
    if (typeof value === 'string') {
      // Работаем как со строкой
    }
  }
  ```

  Narrowing поддерживает `switch`:

  ```typescript
  function foo(value: number | string) {
    switch (typeof value) {
      case 'number':
        // какая-то логика
        break;
      case 'string':
        // какая-то логика
        break;
    }
  }
  ```

  <!--TODO - автору: не хватает описание кода, на что нужно обратить внимание?-->
  
  Перегрузка функций в TypeScript — это тоже пример работы Narrowing:

  ```typescript
  function concat(a: number, b: number): string;
  function concat(a: string, b: string): string;

  function concat(a: any, b: any): string {
    if (typeof a === 'string') {
      return `${a}${b}`; // (parameter) a: string
    } else {
      return `${a.toFixed()}${b.toFixed()}`;
    }
  }
  ```

  Narrowing — большая тема со множеством нюансов. Он часто встречается в TypeScript, поэтому с ним можно будет разобраться на постоянной практике. Подробнее с особенностями работы этого механизма можно ознакомиться в документации — ссылка в конце урока. 

instructions: |

  Реализуйте функцию `last()`, которая извлекает последний элемент из переданного значения. Значением может быть строка или число. Функция возвращает значение того же типа, которое было передано в качестве параметра:

  ```typescript
  // Передаем в качестве параметра строку
  // Функция возвращает строку
  last('hexlet'); // t

  // Передаем в качестве параметра число
  // Функция возвращает число
  last(12345); // 5
  ```

tips:
  - |
    [Официальная документация](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
