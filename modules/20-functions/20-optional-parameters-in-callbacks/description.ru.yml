---

name: Опциональные параметры в колбеках
theory: |

  Опциональные параметры в функциях задаются с помощью знака вопроса после имени переменной, перед двоеточием:

  ```typescript
  function split(str: string, separator?: string)

  split('hexlet');
  split('hexlet,code-basics', ',');
  ```

  В таком случае реальный тип переменной `separator` будет `string | undefined` (`string` или `undefined`).

  Другой вариант задать опциональный параметр, это присвоить значение по умолчанию:

  ```typescript
  // Знака вопроса больше нет, так как есть значение по умолчанию
  function split(str: string, separator: string = ',') {
    // ...
  }

  split('hexlet');
  split('hexlet,code-basics', ',');
  ```

  Зная эту логику, разработчики пытаются применять ее к колбекам, но сталкиваются с ошибками. Представьте себе функцию `filter()`, которая фильтрует числовые массивы по переданному предикату:

  ```typescript
  // Необязательный параметр index
  function filter(coll: number[], callback: (arg: number, index?: number) => boolean) {
    const result: number[] = [];
    coll.forEach((n, index) => {
      // Здесь он передается в колбек
      if (callback(n, index)) {
        result.push(n);
      }
    });
    return result;
  }
  ```

  Как и во встроенном методе `filter()`, в этой функции колбек принимает вторым параметром индекс обрабатываемого элемента массива. В большинстве случаев его не используют, но иногда фильтрация массива делается на основе индексов. И в этой ситуации его указывают. Кажется логичным указать этот параметр как не обязательный.

  Проблема определения выше в том, что оно не работает.

  ```typescript
  // Выполнится без ошибок
  filter([1, 2], (n) => n > 1);
  // Object is possibly 'undefined'
  filter([1, 2], (n, index) => index > n);
  ```

  В данном случае ошибка обозначает то, что из-за "необязательности", внутри колбека в теории может оказаться `undefined`, чего по смыслу происходить не может, индекс всегда определен.

  Правильным решением для таких ситуаций будет отказ от опциональности:

  ```typescript
  function filter(coll: number[], callback: (arg: number, index: number) => boolean) {
    // ...
  }
  ```

  Почему такой код сработает? В JavaScript если функция вызывается с большим количеством параметров, чем определено, то лишние просто игнорируются. TypeScript ведет себя также. Колбеки с меньшим числом параметров всегда могут появляться там, где они же ожидаются с большим числом параметров, при условии совпадении типов общих параметров.

  В примере выше аргументом передается функция `(n) => n > 1`, а вызывается она как `callback(n, index)`, что приводит к игнорированию `index`, при этом никаких ошибок типов не возникает.

instructions: |

  Реализуйте функцию `map()`, которая принимает на вход массив чисел и колбек, который будет использоваться для преобразования каждого числа из массива, в какое-то другое число. Функция возвращает массив с новыми числами.

  ```typescript
  map([3, 9], (n) => n - 3);
  // [0, 6]

  map([8, 9], (n) => n + 8);
  // [16, 17]
  ```
  
  Запрещено пользоваться методом массива map.
  Параметры функции:

  1. Массив чисел
  2. Анонимная функция, принимающая на вход число и возвращающая число. У этой функции есть необязательный параметр - индекс элемента в массиве.

  ```typescript
  map([8, 9], (n, index) => index + n);
  // [8, 10]
  ```

# tips:
#   - |
#     [Ruby-комьюнити](https://slack-ru.hexlet.io/)
