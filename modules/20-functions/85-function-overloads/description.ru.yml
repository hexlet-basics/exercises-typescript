---
name: Перегрузка функций (Function Overloads)
theory: |

  Перегрузка функций — это возможность определить несколько версий одной функции, каждая из которых принимает свой набор параметров. Разберем на примере:

  ```typescript
  function concat(a: number, b: number): string;
  function concat(a: string, b: string): string;

  function concat(a: unknown, b: unknown): string {
    if (typeof a === 'number' && typeof b === 'number') {
      return `${a.toFixed()}${b.toFixed()}`;
    }

    return `${a}${b}`;
  }

  concat('one', 'two'); // onetwo
  concat(3, 5.34); // 35
  concat(1.33, 10); // 110
  ```

  Здесь определяется одна функция `concat()`. У нее две версии, которые выполняют конкатенацию, но делают это по-разному:
  
  * Первая версия — принимает на вход два числа. У чисел сначала отбрасывается дробная часть, потом они конкатенируются
  * Вторая версия — принимает на вход две строки. Строки конкатенируются сразу
  
  <!--TODO - автору: студент будет понимать, что значит конкаенация? Если нет, нужно либо более понятным словом написать, либо объяснить это.-->

  Реализация поведения для обеих версий делается в третьей функции с тем же именем. При этом описание параметров должно подходить под каждую версию функции. В примере выше типы параметров определены как `unknown`. Это дает возможность вызывать функцию как со строками, так и с числами.

  То, по какой ветке идти, определяется с помощью проверки типов. В примере выше достаточно проверить тип только первого параметра, так как второй в таком случае точно будет строкой. Это обеспечивает система типов и компилятор.

  Для перезагрузки не обязательно использовать объявление функций. То же самое можно сделать с помощью стрелочной функции:

  ```
  const concat: {
    (a: number, b: number): string;
    (a: string, b: string): string;
  } = (a: unknown, b: unknown) => {
    if (typeof a === 'number' && typeof b === 'number') {
      return `${a.toFixed()}${b.toFixed()}`;
    }

    return `${a}${b}`;
  }

  // с использованием алиасов
  type Overloaded = {
    (a: number, b: number): string;
    (a: string, b: string): string;
  }

  const concat: Overloaded = (a: unknown, b: unknown) {...}
  ```

  <!--Todo - автору: код выше нужно описать - на что братить внимание. А коду ниже нужно сделать подводку. Сейчас абзац, который есть между ними, не поонятно, к чему относится-->
  
  Перегрузка функций не ограничивается двумя версиями. Их может быть сколько угодно. Главное, что в конце всегда описывается функция, которая является общей по параметрам для всех вариантов и внутри которой описывается вся логика для каждого варианта:

  ```typescript
  function add(a: number, b: number, c: number): number;
  function add(a: number, b: number): number;
  function add(a: string, b: string): string;

  // Сигнатура подходит под все примеры выше
  function add(a: unknown, b: unknown, c?: number): unknown {
    // тут вся логика
    if (c === undefined) {
      // ...
    }
  }
  ```
  
  <!--Todo - автору: код выше нужно описать - на что обратить внимание. А коду ниже нужно сделать подводку. Сейчас абзац, который есть между ними, не поонятно, к чему относится-->
  
  В статических языках перегрузка функций используется достаточно часто, но там она устроена не как в TypeScript. В этих языках создается несколько разных функций, которые с точки зрения программиста имеют одно имя. Поэтому там не нужна общая функция. Логика каждого варианта описывается внутри, что избавляет код от необходимости реализовывать условную логику.

  ```kotlin
  // Пример на Kotlin
  fun sayHello (name:String) = println("Hi ${name}")
  fun sayHello (firstName:String, lastName:String) {
    return println("Hello ${firstName} ${lastName}")
  }

  sayHello("John", "Doe") // Hello John Doe
  sayHello("Elon") // Hi Elon
  ```

  Можно задуматься, зачем в TypeScript такая реализация и какие проблемы она решает. Это как и многое другое в TypeScript попытка учесть все возможные варианты написания кода на JavaScript и покрыть их типами для написания типобезопасного кода. В JavaScript нередко создают функции, которые принимают на вход разные типы данных в разных вариациях. Перегрузка функций позволяет описать подобные функции в TypeScript, иначе пришлось бы использовать `any` и следить за типами самостоятельно.

  Технически после трансляции в JavaScript остается одна функция, как раз та, что содержит тело.

  Перегрузка функций в TypeScript — это механизм, который стоит использовать, когда нет другого выбора. В большинстве случаев вместо перегрузки используются объединения или дженерики, о которых мы поговорим позже. Перегрузка нужна, когда между параметрами есть зависимость, например, если оба параметра — строки, либо оба параметра — числа.

instructions: |

  Реализуйте и экспортируйте по умолчанию функцию `sayHello()`, которая аналогична примеру на Kotlin из теории:

  ```typescript
  sayHello('John'); // Hi John
  sayHello('Mila', 'Mala'); // Hello Mila Mala
  ```

tips:
  - |
    [Официальная документация](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
