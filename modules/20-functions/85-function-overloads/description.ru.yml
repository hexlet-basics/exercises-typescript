---
name: Перегрузка функций (Function Overloads)
theory: |

  Перегрузка функций - возможность определить несколько версий одной функции, каждая из которых принимает свой собственный набор параметров. Разберем на примере:

  ```typescript
  function concat(a: number, b: number): string;
  function concat(a: string, b: string): string;

  function concat(a: unknown, b: unknown): string {
    if (typeof a === 'number') {
      return `${a.toFixed()}${b.toFixed()}`;
    }

    return `${a}${b}`;
  }

  concat('one', 'two'); // onetwo
  concat(3, 5.34); // 35
  concat(1.33, 10); // 110
  ```

  Здесь определяется одна функция `concat()`, у которой две версии, одна принимает на вход два числа, другая две строки. Обе версии выполняют конкатенацию, но делают это по-разному. Строки конкатенируются сразу, а вот у чисел сначала отбрасывается дробная часть.

  Реализация поведения для обеих версий делается в третьей функции с тем же именем, но с таким описанием параметров, которое подойдет под каждую версию функции. В примере выше типы параметров определены как `unknown`, что дает возможность вызывать функцию как со строками, так и с числами.

  Вся логика для всех версий функций описывается в этом последнем определении. То по какой ветке идти, делается с помощью проверки типов. В примере выше достаточно проверить тип только первого параметра, так как второй в таком случае точно будет строкой. Это обеспечивает система типов и компилятор.

  Для перезагрузки не обязательно использовать объявление функций, все то же самое можно сделать при помощи стрелочной функции:

  ```
  const concat: {
    (a: number, b: number): string;
    (a: string, b: string): string;
  } = (a: unknown, b: unknown) => {
    if (typeof a === 'number') {
      return `${a.toFixed()}${b.toFixed()}`;
    }

    return `${a}${b}`;
  }

  // с использованием алиасов
  type Overloaded = {
    (a: number, b: number): string;
    (a: string, b: string): string;
  }

  const concat: Overloaded = (a: unknown, b: unknown) {...}
  ```

  Перегрузка функций не ограничивается двумя версиями. Версий может быть сколько угодно, главное то, что в конце всегда описывается функция, которая является общей по параметрам для всех вариантов и внутри которой описывается вся логика для каждого варианта.

  ```typescript
  function add(a: number, b: number, c: number): number;
  function add(a: number, b: number): number;
  function add(a: string, b: string): string;

  // Сигнатура подходит под все примеры выше
  function add(a: unknown, b: unknown, c?: number): unknown {
    // тут вся логика
    if (c === undefined) {
      // ...
    }
  }
  ```

  В статических языках перегрузка функций используется достаточно часто, но она там устроена не так как в TypeScript. В этих языках, в реальности, создается несколько разных функций, которые с точки зрения программиста имеют одно имя. Поэтому там не нужна общая функция. Логика каждого варианта описывается внутри, что избавляет код от необходимости реализовывать условную логику.

  ```kotlin
  // Пример на Kotlin
  fun sayHello (name:String) = println("Hi ${name}")
  fun sayHello (firstName:String, lastName:String) {
    return println("Hello ${firstName} ${lastName}")
  }

  sayHello("John", "Doe") // Hello John Doe
  sayHello("Elon") // Hi Elon
  ```

  Возникает вопрос, зачем в TypeScript именно такая реализация и какие проблемы она решает? Это, как и многое другое в TypeScript, попытка учесть все возможные варианты написания кода на JavaScript и покрыть их типами для написания типобезопасного кода. В JavaScript не редко создают функции, которые принимают на вход совершенно разные типы данных в разных вариациях. Перегрузка функций, позволяет описать подобные функции в TypeScript, иначе пришлось бы использовать `any` и следить за типами самостоятельно.

  _Технически, после трансляции в JavaScript остается ровно одна функция, как раз та, что содержит тело_

  Перегрузка функций в TypeScript - механизм, который стоит использовать только тогда, когда нет другого выбора. В большинстве случаев вместо перегрузки используются объединения или дженерики, о которых мы поговорим позже. Перегрузка нужна тогда, когда между параметрами есть зависимость, например если оба параметра строки, либо оба параметра числа.

instructions: |

  Реализуйте и экспортируйте по умолчанию функцию `sayHello()`, которая аналогична примеру на Kotlin из теории:

  ```typescript
  sayHello('John'); // Hi John
  sayHello('Mila', 'Mala'); // Hello Mila Mala
  ```

tips:
  - |
    [Официальная документация](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
