---

name: Дженерики (Функции)
theory: |

  Зачем вообще нужны дженерики? Чтобы правильно ответить на этот вопрос, нужно представить, что дженерики пропали из языка. К чему это приведет? Правильный ответ: дублированию кода. Придется описывать один и тот же алгоритм для разных типов данных множество раз. Возьмем для примера функцию `last()` возвращающую последний элемент массива. Ниже ее обобщенная версия:

  ```typescript
  function last(coll: T[]): T {
    return coll.at(-1);
  }

  А теперь попробуем реализовать то же поведение на обычных функциях. Для этого нам придется создать по одной функции для каждого типа. Причем имя функци должно быть уникальным.

  ```typescript
  function lastForNumberType(coll: number[]): number {
    return coll.at(-1);
  }

  function lastForStringType(coll: string[]): string {
    return coll.at(-1);
  }

  // Тут определения для всех остальных типов
  ```
  Если типов несколько, то количество функций, которые нужно определить, будет определяться как произведение количества всех возможных типов на количество параметров типа.

  Реализация дженерика с помощью перегруженной функции упрощает задачу. Тогда не придется создавать новые имена:

  ```typescript
  function last(coll: number[]): number;
  function last(coll: string[]): string;
  // Тут определения для всех остальных типов

  function last(coll: any[]): any {
    return coll.at(-1);
  }
  ```

  _В случае TypeScript даже не будет дублироваться логика, но это особенность именно TypeScript, в других статически типизированных языках придется дублировать и логику_

  Какой бы вариант реализации мы не выбрали, соблюдаются две вещи:

  * Значения передаваемые во внутрь никак не используются. Они только перекладываются из одного места в другое.
  * Логика работы всегда остается одной и той же. Условные конструкции по типу данных отсутствуют.

  В Computer Science, свойство функции, позволяющее обрабатывать значения разных типов одним способом (используя один алгоритм) называется параметрическим полиморфизмом. То есть дженерики это реализация параметрического полиморфизма в TypeScript.

  Параметрический полиморфизм играет важную роль в статически типизированных языках, там где приходится явно указывать типы у функций. Он, так или иначе, есть почти во всех высокоуровневых статически типизированных языках. В Java и C# это тоже называется дженериками. В C++ используется названия шаблоны, но смысл от этого не меняется (хотя шаблоны в c++ это больше чем параметрический полиморфизм).

  В противовес статически типизированным языкам, в языках с динамической типизацией, таких как JavaScript, Python, Ruby, PHP дженерики не нужны. В подобных языках любой обобщенный алгоритм автоматически работает для всех типов данных.

instructions: |

  Реализуйте описание обощенного типа `MyArray`, который представляет из себя аналог массива из JavaScript. Пример использования объекта этого типа:

  ```typescript
  const coll: MyArray<number> = ...
  coll.push(1); // 1
  coll.push(10); // 2
  coll.push(99); // 3

  const newColl = coll.filter((value) => value % 2 == 0);
  console.log(newColl.items); // [10]
  ```

  Тип включает в себя два метода: [push()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) и [filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) совпадающие по сигнатуре с методами Array. Данные внутри должны храниться в свойстве `items`.

tips:
  - |
    [Ограничения дженериков](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
