---

name: Иерархия типов
theory: |

  Один из примеров с первого взгляда не очевидной ошибки `Type X is not assignable to type Y` в примере со spaceship оператором, аналогом которого может служить `Math.sign` для сортировки с использованием callback, ожидающим возврат `-1 | 0 | 1`:

  ```typescript
  type ComparatorCallback = (item1: number, item2: number, index: number) => -1 | 0 | 1
  declare function sort(arr: Array<number>, callback: ComparatorCallback): Array<number>

  const arr = [1, 2, 3];
  const comparator = (item1: number, item2: number) => Math.sign(item1 - item2);
  //    ^? const comparator = (item1: number, item2: number) => number;

  sort(arr, comparator) // Error: Type 'number' is not assignable to type '0 | 1 | -1'.
  //        ~~~~~~~~~~
  ```

  Проверка типов системой TypeScript выдала ошибку, что объединение литеральных типов `0 | 1 | -1` не совместимо с типом `number`. И на первый взгляд кажется, что система типов ошибается и пора использовать `any`, но, если мы подумаем о литеральных числовых типах как о подмножествах `number`, все становится логично.

  В определении системы типов есть несколько подходов, например, считать каждый тип отдельной вселенной и давать на откуп пользователям определение всех взаимодействий между ними. Или другой подход, когда вселенная одна и внутри нее есть более мелкие единицы.

  Второй подход как раз про TypeScript, как и, например, про Java, где все наследуется от `Object`.

  Первый же подход хорошо описывается теорией множеств. Здесь одну из ключевых ролей играют подмножества и надмножества. Множество `A` является подмножеством `B`, если любой элемент, принадлежащий `A`, также принадлежит `B`. Эта идея также отлично описывает идею связи между типами, создавая тем самым иерархию типов, которая в свою очередь определяет возможность присвоить переменную одного типа переменной другого типа.

  В уроке про литеральные типы мы сказали, что они существуют для четырех типов данных: `boolean`, `string`, `number`, `BigInt`. Таким образом любой литеральный тип мы можем присвоить переменной соответствующего типа:

  ```typescript
  let num: number = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  num = two;
  num = notTrue; // Type 'boolean' is not assignable to type 'number'.
  ```

  Анализатор успешно пропустил присваивание литерального типа числа к `number`, но литеральный `boolean` тип мы уже не смогли присвоить. Для того, чтобы решить эту проблему мы могли бы использовать объединение типов `number | boolean`, но если мы не уверенны, что может быть присвоено, то нам пришлось бы делать объединение с потенциально огромным числом типов.

  Тут нам приходит на помощь тип `unknown`, представляющий собой надмножество всех доступных типов, который позволяет присвоить переменной значение произвольного типа:

  ```typescript
  let unknownValue: unknown = 1;
  const two: 2 = 2;
  const notTrue: false = false;

  unknownValue = two;
  unknownValue = notTrue; // OK
  ```

  Куда более редкий случай на практике, когда нам нужно быть уверенными, что переменной не будет присвоено никакого значения, позволяет реализовать тип `never`. С точки зрения теории множеств, это пустое множество, не содержащее никакого элемента:

  ```typescript
  let neverValue: never;
  const two: 2 = 2;

  neverValue = two; // Type 'number' is not assignable to type 'never'
  ```

  Из текущих знаний мы можем составить следующую картинку множества типов TypeScript:

  <!-- TODO: добавить картинку -->

  ```typescript
  type StringNumber = number | string;

  let value: StringNumber = 10;
  value = 'string'
  ```

  <!-- TODO: добавить картинку с кругами Эйлера -->

  Через объединение множеств чисел и строк мы получили множество, содержащее сразу и числа и строки. Переменной такого типа можно присвоить также любое подмножество:

  ```typescript
  type StringNumber = number | string;
  type One = 1;

  const one: One = 1;
  const value: StringNumber = one;
  ```

  Здесь `1` используется как литеральный тип, которое представляет из себя множество из одного элемента – единицы. В множество `number` также входят все объединения литеральных типов чисел:

  ```typescript
  type NumberUnion = -2 | -1 | 1 | 2

  const one: NumberUnion = 1;
  const num: number = one;
  ```

  Такое подмножество типов называют подтипом, а само множество супертипом.

  <!-- TODO: добавить картинку с кругом number и внутри кругом NumberUnion -->

  Взаимосвязи подтипов и супертипов являются ключевой концепцией любого статически типизированного языка и образуют иерархию типов. Это важно для понимания возможности использования одного типа, когда ожидается использование другого.

  <!-- TODO: тут нужно рассказать про приведение -->

instructions: |

  FIXME: В процессе ...

tips:
  - |
    [Как устроена система типов в TypeScript](https://ru.hexlet.io/blog/posts/sistema-tipov-v-typescript)
