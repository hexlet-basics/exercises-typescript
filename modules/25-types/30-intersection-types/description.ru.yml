---
name: Пересечение (Intersections Types)
theory: |

  Вместе с объединением важной операцией в теории множеств является пересечение. Для разработчиков, привыкших к динамике JavaScript, эта операция может показаться менее значимой, но без нее не обойтись, например при описании типа слияния объектов.

  Пересечение указывается с помощью символа `&`, по обе стороны от которого располагаются типы. Давайте определим тип объекта со статусом заказа, а затем более строгий тип с точной ценой в сотню:

  ```typescript
  type OrderStatus = 'Created' | 'Paid' | 'Shipped' | 'Delivered';
  type Order = {
    status: OrderStatus,
  }

  type OneHundredOrder = Order & {
    cost: 100
  }

  const myOrder: OneHundredOrder = {
      status: 'Created',
      cost: 100
  }
  ```

  Тип, который получился в итоге, `OneHundredOrder`, из пересечения объектного типа с полем `status` **И** `cost`, содержит оба этих поля. Тем самым мы получили ограничение по объекту, которое требует от значения наличия обоих этих полей с конкретными значениями, так как мы использовали литеральные типы при описании.

  <!-- FIXME: переписать блоки ниже -->

  С точки зрения теории множеств, при пересечении мы получаем новое множество, содержащее значения, которые есть в обоих множествах. Тем самым если мы объявим переменную `const StringAndNumber: string & number`, то ей нужно будет присвоить такое значение, которое одновременно принадлежит множествам `string` и `number`, то есть является одновременно и строкой, и числом.

  Когда в теории множеств пересекается два множества, не содержащих общих элементов, то получается пустое множество. В TypeScript есть специальный тип, обозначающий пустое множество, — `never`.

instructions: |

  Реализуйте функцию `intersection(...arrays)`, которая принимает массивы и возвращает массив уникальных элементов, которые встречаются в каждом из них.
  Небольшое упрощение - в массивах ожидаются элементы типа number | string | boolean | null.

  ```typescript
  const RGB = ['Red', 'Green', 'Blue'];
  const RYB = ['Red', 'Yellow', 'Blue'];

  intersection(RGB, RYB); // ['Red', 'Blue']
  intersection(RGB, []); // []
  ```
