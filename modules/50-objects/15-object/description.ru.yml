---

name: Тип object
theory: |

  В некоторых ситуациях, мы хотим ограничить входной параметр функции типом "любой объект". Например, для функции проверяющей наличие ключей в объекте. Существует несколько способов сделать такую проверку и не все из них работают так как ожидается. Посмотрите на пример:

  ```typescript
  // В качестве типа используется {}
  function toString(obj: {}) {
    return obj.toString();
  }

  toString('wow'); // Ok!
  toString(123); // Ok!
  toString({}); // Ok!
  ```

  Пустой объектный тип `{}` подразумевает под собой объект любой структуры и ограничивает множество всех значений, за исключением `null` и `undefined`. Пустой интерфейс работает также как и пустой объектный тип. Это вряд ли то, что мы ожидали.

  Тип Тип `Object` — это тип объекта и работает так же, как тип `{}` с некоторыми отличиями. Он предопределяет типы некоторых встроенных методов, например, `toString()`, а тип `{}` этого не делает. Например:

  ```typescript
  const foo: {} = {
    toString() {
     return 1; // Ok!
    }
  };

  const bar: Object = {
    toString() {
      return 1; // Error!
    }
  };
  ```

  Второе определение `bar` не работает, потому что тип `Object` указывает на то, что метод `toString()` должен возвращать строку.

  Если мы хотим работать с не примитивными значениями, то для этого существует еще один тип `object` (с маленькой буквы):

  ```typescript
  function toString(obj: object) {
    return obj.toString();
  }

  foo('wow'); // Error!
  foo(123); // Error!
  foo({}); // Ok!
  ```

  С помощью типа `object` нельзя получить доступ к свойствам объекта, для такой задачи используются уже другие механизмы.

instructions: |

  Реализуйте функцию `extract(object, keys)`, которая возвращает новый объект c указанными ключами. Например:

  ```typescript
  const user = {
    name: 'Tirion',
    email: 'tirion@lanister.got',
    age: 35,
  }

  extract(user, ['name', 'age']); // { name: 'Tirion', age: 35 }
  ```
